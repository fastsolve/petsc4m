/*
 * codegen/lib/mptSolveCRS/mptSolveCRS_mex.c
 *
 * Auxiliary code for mexFunction of mptSolveCRS
 *
 * C source code generated by m2c.
 * %#m2c options: codegenArgs=-args {} mptSolveCRS_4args -args {coder.typeof(int32(0), [inf,1]), coder.typeof(int32(0), [inf,1]), coder.typeof(0, [inf,1]), coder.typeof(0, [inf,1])} mptSolveCRS_5args -args {coder.typeof(int32(0), [inf,1]), coder.typeof(int32(0), [inf,1]), coder.typeof(0, [inf,1]), coder.typeof(0, [inf,1]), PetscKSPType} mptSolveCRS_6args -args {coder.typeof(int32(0), [inf,1]), coder.typeof(int32(0), [inf,1]), coder.typeof(0, [inf,1]), coder.typeof(0, [inf,1]), PetscKSPType, 0} mptSolveCRS_7args -args {coder.typeof(int32(0), [inf,1]), coder.typeof(int32(0), [inf,1]), coder.typeof(0, [inf,1]), coder.typeof(0, [inf,1]), PetscKSPType, 0, int32(0)} mptSolveCRS_8args -args {coder.typeof(int32(0), [inf,1]), coder.typeof(int32(0), [inf,1]), coder.typeof(0, [inf,1]), coder.typeof(0, [inf,1]), PetscKSPType, 0, int32(0), PetscPCType} mptSolveCRS_9args -args {coder.typeof(int32(0), [inf,1]), coder.typeof(int32(0), [inf,1]), coder.typeof(0, [inf,1]), coder.typeof(0, [inf,1]), PetscKSPType, 0, int32(0), PetscPCType, PetscMatSolverPackage} mptSolveCRS_10args -args {coder.typeof(int32(0), [inf,1]), coder.typeof(int32(0), [inf,1]), coder.typeof(0, [inf,1]), coder.typeof(0, [inf,1]), PetscKSPType, 0, int32(0), PetscPCType, PetscMatSolverPackage, coder.typeof(0, [inf,1])} mptSolveCRS_11args -args {coder.typeof(int32(0), [inf,1]), coder.typeof(int32(0), [inf,1]), coder.typeof(0, [inf,1]), coder.typeof(0, [inf,1]), PetscKSPType, 0, int32(0), PetscPCType, PetscMatSolverPackage, coder.typeof(0, [inf,1]), coder.typeof(char(0), [1, inf])}  enableInline=1 withPetsc=1
 *
 */

#ifdef MATLAB_MEX_FILE
#include "mex.h"
#else
#include "matrix.h"
#endif
/* Include the C file generated by codegen in lib mode */
#include "mptSolveCRS.h"
#include "m2c.c"
/* Include declaration of some helper functions. */
#include "lib2mex_helper.c"

void mptSolveCRS_api(const mxArray ** prhs, const mxArray **plhs) {

    int32_T              *flag;
    real64_T             *relres;
    int32_T              *iter;

    /* Preallocate output variables */
    {mwSize l_size[] = {1, 1};
    *(void **)&flag = prealloc_mxArray((mxArray**)&plhs[1], mxINT32_CLASS, 2, l_size); }
    {mwSize l_size[] = {1, 1};
    *(void **)&relres = prealloc_mxArray((mxArray**)&plhs[2], mxDOUBLE_CLASS, 2, l_size); }
    {mwSize l_size[] = {1, 1};
    *(void **)&iter = prealloc_mxArray((mxArray**)&plhs[3], mxINT32_CLASS, 2, l_size); }

    /* Invoke the target function */
    mptSolveCRS_initialize();

    mptSolveCRS(flag, relres, iter);

    mptSolveCRS_terminate();

    /* Marshall out function outputs */
    /* Creating empty mxArray for pruned variable x */
    {mwSize l_size[] = {0, 1};
    prealloc_mxArray((mxArray**)&plhs[0], mxDOUBLE_CLASS, 2, l_size); }
    /* Nothing to do for plhs[1] */
    /* Nothing to do for plhs[2] */
    /* Nothing to do for plhs[3] */

}
void mptSolveCRS_4args_api(const mxArray ** prhs, const mxArray **plhs) {

    emxArray_int32_T     Arows;
    emxArray_int32_T     Acols;
    emxArray_real_T      Avals;
    emxArray_real_T      b;
    emxArray_real_T      x;

    int32_T              *flag;
    real64_T             *relres;
    int32_T              *iter;

    /* Marshall in function inputs */
    if (mxGetNumberOfElements(prhs[0]) && mxGetClassID(prhs[0]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_4args:WrongInputType",
            "Input argument Arows has incorrect data type. int32 is expected.");
    alias_mxArray_to_emxArray(prhs[0], (emxArray__common *)&Arows, "Arows", 1);
    if (mxGetNumberOfElements(prhs[1]) && mxGetClassID(prhs[1]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_4args:WrongInputType",
            "Input argument Acols has incorrect data type. int32 is expected.");
    alias_mxArray_to_emxArray(prhs[1], (emxArray__common *)&Acols, "Acols", 1);
    if (mxGetNumberOfElements(prhs[2]) && mxGetClassID(prhs[2]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_4args:WrongInputType",
            "Input argument Avals has incorrect data type. double is expected.");
    alias_mxArray_to_emxArray(prhs[2], (emxArray__common *)&Avals, "Avals", 1);
    if (mxGetNumberOfElements(prhs[3]) && mxGetClassID(prhs[3]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_4args:WrongInputType",
            "Input argument b has incorrect data type. double is expected.");
    alias_mxArray_to_emxArray(prhs[3], (emxArray__common *)&b, "b", 1);

    /* Preallocate output variables */
    init_emxArray((emxArray__common*)&x, 1);
    {mwSize l_size[] = {1, 1};
    *(void **)&flag = prealloc_mxArray((mxArray**)&plhs[1], mxINT32_CLASS, 2, l_size); }
    {mwSize l_size[] = {1, 1};
    *(void **)&relres = prealloc_mxArray((mxArray**)&plhs[2], mxDOUBLE_CLASS, 2, l_size); }
    {mwSize l_size[] = {1, 1};
    *(void **)&iter = prealloc_mxArray((mxArray**)&plhs[3], mxINT32_CLASS, 2, l_size); }

    /* Invoke the target function */
    mptSolveCRS_initialize();

    mptSolveCRS_4args(&Arows, &Acols, &Avals, &b, &x, flag, relres, iter);

    mptSolveCRS_terminate();

    /* Marshall out function outputs */
    plhs[0] = move_emxArray_to_mxArray((emxArray__common*)&x, mxDOUBLE_CLASS);
    /* Nothing to do for plhs[1] */
    /* Nothing to do for plhs[2] */
    /* Nothing to do for plhs[3] */

    /* Free temporary variables */
    free_emxArray((emxArray__common*)&Arows);
    free_emxArray((emxArray__common*)&Acols);
    free_emxArray((emxArray__common*)&Avals);
    free_emxArray((emxArray__common*)&b);
    free_emxArray((emxArray__common*)&x);
}
void mptSolveCRS_5args_api(const mxArray ** prhs, const mxArray **plhs) {

    emxArray_int32_T     Arows;
    emxArray_int32_T     Acols;
    emxArray_real_T      Avals;
    emxArray_real_T      b;
    emxArray_char_T      solver;
    emxArray_real_T      x;

    int32_T              *flag;
    real64_T             *relres;
    int32_T              *iter;

    /* Marshall in function inputs */
    if (mxGetNumberOfElements(prhs[0]) && mxGetClassID(prhs[0]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_5args:WrongInputType",
            "Input argument Arows has incorrect data type. int32 is expected.");
    alias_mxArray_to_emxArray(prhs[0], (emxArray__common *)&Arows, "Arows", 1);
    if (mxGetNumberOfElements(prhs[1]) && mxGetClassID(prhs[1]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_5args:WrongInputType",
            "Input argument Acols has incorrect data type. int32 is expected.");
    alias_mxArray_to_emxArray(prhs[1], (emxArray__common *)&Acols, "Acols", 1);
    if (mxGetNumberOfElements(prhs[2]) && mxGetClassID(prhs[2]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_5args:WrongInputType",
            "Input argument Avals has incorrect data type. double is expected.");
    alias_mxArray_to_emxArray(prhs[2], (emxArray__common *)&Avals, "Avals", 1);
    if (mxGetNumberOfElements(prhs[3]) && mxGetClassID(prhs[3]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_5args:WrongInputType",
            "Input argument b has incorrect data type. double is expected.");
    alias_mxArray_to_emxArray(prhs[3], (emxArray__common *)&b, "b", 1);
    if (mxGetNumberOfElements(prhs[4]) && mxGetClassID(prhs[4]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_5args:WrongInputType",
            "Input argument solver has incorrect data type. char is expected.");
    alias_mxArray_to_emxArray(prhs[4], (emxArray__common *)&solver, "solver", 2);

    /* Preallocate output variables */
    init_emxArray((emxArray__common*)&x, 1);
    {mwSize l_size[] = {1, 1};
    *(void **)&flag = prealloc_mxArray((mxArray**)&plhs[1], mxINT32_CLASS, 2, l_size); }
    {mwSize l_size[] = {1, 1};
    *(void **)&relres = prealloc_mxArray((mxArray**)&plhs[2], mxDOUBLE_CLASS, 2, l_size); }
    {mwSize l_size[] = {1, 1};
    *(void **)&iter = prealloc_mxArray((mxArray**)&plhs[3], mxINT32_CLASS, 2, l_size); }

    /* Invoke the target function */
    mptSolveCRS_initialize();

    mptSolveCRS_5args(&Arows, &Acols, &Avals, &b, &solver, &x, flag, relres, iter);

    mptSolveCRS_terminate();

    /* Marshall out function outputs */
    plhs[0] = move_emxArray_to_mxArray((emxArray__common*)&x, mxDOUBLE_CLASS);
    /* Nothing to do for plhs[1] */
    /* Nothing to do for plhs[2] */
    /* Nothing to do for plhs[3] */

    /* Free temporary variables */
    free_emxArray((emxArray__common*)&Arows);
    free_emxArray((emxArray__common*)&Acols);
    free_emxArray((emxArray__common*)&Avals);
    free_emxArray((emxArray__common*)&b);
    free_emxArray((emxArray__common*)&solver);
    free_emxArray((emxArray__common*)&x);
}
void mptSolveCRS_6args_api(const mxArray ** prhs, const mxArray **plhs) {

    emxArray_int32_T     Arows;
    emxArray_int32_T     Acols;
    emxArray_real_T      Avals;
    emxArray_real_T      b;
    emxArray_char_T      solver;
    emxArray_real_T      x;

    real64_T             rtol;
    int32_T              *flag;
    real64_T             *relres;
    int32_T              *iter;

    /* Marshall in function inputs */
    if (mxGetNumberOfElements(prhs[0]) && mxGetClassID(prhs[0]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_6args:WrongInputType",
            "Input argument Arows has incorrect data type. int32 is expected.");
    alias_mxArray_to_emxArray(prhs[0], (emxArray__common *)&Arows, "Arows", 1);
    if (mxGetNumberOfElements(prhs[1]) && mxGetClassID(prhs[1]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_6args:WrongInputType",
            "Input argument Acols has incorrect data type. int32 is expected.");
    alias_mxArray_to_emxArray(prhs[1], (emxArray__common *)&Acols, "Acols", 1);
    if (mxGetNumberOfElements(prhs[2]) && mxGetClassID(prhs[2]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_6args:WrongInputType",
            "Input argument Avals has incorrect data type. double is expected.");
    alias_mxArray_to_emxArray(prhs[2], (emxArray__common *)&Avals, "Avals", 1);
    if (mxGetNumberOfElements(prhs[3]) && mxGetClassID(prhs[3]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_6args:WrongInputType",
            "Input argument b has incorrect data type. double is expected.");
    alias_mxArray_to_emxArray(prhs[3], (emxArray__common *)&b, "b", 1);
    if (mxGetNumberOfElements(prhs[4]) && mxGetClassID(prhs[4]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_6args:WrongInputType",
            "Input argument solver has incorrect data type. char is expected.");
    alias_mxArray_to_emxArray(prhs[4], (emxArray__common *)&solver, "solver", 2);
    if (mxGetNumberOfElements(prhs[5]) && mxGetClassID(prhs[5]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_6args:WrongInputType",
            "Input argument rtol has incorrect data type. double is expected.");
    if (mxGetNumberOfElements(prhs[5]) != 1)
        mexErrMsgIdAndTxt("mptSolveCRS_6args:WrongSizeOfInputArg",
            "Argument rtol should be a scalar.");
    rtol = *(real64_T*)mxGetData(prhs[5]);

    /* Preallocate output variables */
    init_emxArray((emxArray__common*)&x, 1);
    {mwSize l_size[] = {1, 1};
    *(void **)&flag = prealloc_mxArray((mxArray**)&plhs[1], mxINT32_CLASS, 2, l_size); }
    {mwSize l_size[] = {1, 1};
    *(void **)&relres = prealloc_mxArray((mxArray**)&plhs[2], mxDOUBLE_CLASS, 2, l_size); }
    {mwSize l_size[] = {1, 1};
    *(void **)&iter = prealloc_mxArray((mxArray**)&plhs[3], mxINT32_CLASS, 2, l_size); }

    /* Invoke the target function */
    mptSolveCRS_initialize();

    mptSolveCRS_6args(&Arows, &Acols, &Avals, &b, &solver, rtol, &x, flag, relres, iter);

    mptSolveCRS_terminate();

    /* Marshall out function outputs */
    plhs[0] = move_emxArray_to_mxArray((emxArray__common*)&x, mxDOUBLE_CLASS);
    /* Nothing to do for plhs[1] */
    /* Nothing to do for plhs[2] */
    /* Nothing to do for plhs[3] */

    /* Free temporary variables */
    free_emxArray((emxArray__common*)&Arows);
    free_emxArray((emxArray__common*)&Acols);
    free_emxArray((emxArray__common*)&Avals);
    free_emxArray((emxArray__common*)&b);
    free_emxArray((emxArray__common*)&solver);
    free_emxArray((emxArray__common*)&x);
}
void mptSolveCRS_7args_api(const mxArray ** prhs, const mxArray **plhs) {

    emxArray_int32_T     Arows;
    emxArray_int32_T     Acols;
    emxArray_real_T      Avals;
    emxArray_real_T      b;
    emxArray_char_T      solver;
    emxArray_real_T      x;

    real64_T             rtol;
    int32_T              maxiter;
    int32_T              *flag;
    real64_T             *relres;
    int32_T              *iter;

    /* Marshall in function inputs */
    if (mxGetNumberOfElements(prhs[0]) && mxGetClassID(prhs[0]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_7args:WrongInputType",
            "Input argument Arows has incorrect data type. int32 is expected.");
    alias_mxArray_to_emxArray(prhs[0], (emxArray__common *)&Arows, "Arows", 1);
    if (mxGetNumberOfElements(prhs[1]) && mxGetClassID(prhs[1]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_7args:WrongInputType",
            "Input argument Acols has incorrect data type. int32 is expected.");
    alias_mxArray_to_emxArray(prhs[1], (emxArray__common *)&Acols, "Acols", 1);
    if (mxGetNumberOfElements(prhs[2]) && mxGetClassID(prhs[2]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_7args:WrongInputType",
            "Input argument Avals has incorrect data type. double is expected.");
    alias_mxArray_to_emxArray(prhs[2], (emxArray__common *)&Avals, "Avals", 1);
    if (mxGetNumberOfElements(prhs[3]) && mxGetClassID(prhs[3]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_7args:WrongInputType",
            "Input argument b has incorrect data type. double is expected.");
    alias_mxArray_to_emxArray(prhs[3], (emxArray__common *)&b, "b", 1);
    if (mxGetNumberOfElements(prhs[4]) && mxGetClassID(prhs[4]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_7args:WrongInputType",
            "Input argument solver has incorrect data type. char is expected.");
    alias_mxArray_to_emxArray(prhs[4], (emxArray__common *)&solver, "solver", 2);
    if (mxGetNumberOfElements(prhs[5]) && mxGetClassID(prhs[5]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_7args:WrongInputType",
            "Input argument rtol has incorrect data type. double is expected.");
    if (mxGetNumberOfElements(prhs[5]) != 1)
        mexErrMsgIdAndTxt("mptSolveCRS_7args:WrongSizeOfInputArg",
            "Argument rtol should be a scalar.");
    rtol = *(real64_T*)mxGetData(prhs[5]);
    if (mxGetNumberOfElements(prhs[6]) && mxGetClassID(prhs[6]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_7args:WrongInputType",
            "Input argument maxiter has incorrect data type. int32 is expected.");
    if (mxGetNumberOfElements(prhs[6]) != 1)
        mexErrMsgIdAndTxt("mptSolveCRS_7args:WrongSizeOfInputArg",
            "Argument maxiter should be a scalar.");
    maxiter = *(int32_T*)mxGetData(prhs[6]);

    /* Preallocate output variables */
    init_emxArray((emxArray__common*)&x, 1);
    {mwSize l_size[] = {1, 1};
    *(void **)&flag = prealloc_mxArray((mxArray**)&plhs[1], mxINT32_CLASS, 2, l_size); }
    {mwSize l_size[] = {1, 1};
    *(void **)&relres = prealloc_mxArray((mxArray**)&plhs[2], mxDOUBLE_CLASS, 2, l_size); }
    {mwSize l_size[] = {1, 1};
    *(void **)&iter = prealloc_mxArray((mxArray**)&plhs[3], mxINT32_CLASS, 2, l_size); }

    /* Invoke the target function */
    mptSolveCRS_initialize();

    mptSolveCRS_7args(&Arows, &Acols, &Avals, &b, &solver, rtol, maxiter, &x, flag, relres, iter);

    mptSolveCRS_terminate();

    /* Marshall out function outputs */
    plhs[0] = move_emxArray_to_mxArray((emxArray__common*)&x, mxDOUBLE_CLASS);
    /* Nothing to do for plhs[1] */
    /* Nothing to do for plhs[2] */
    /* Nothing to do for plhs[3] */

    /* Free temporary variables */
    free_emxArray((emxArray__common*)&Arows);
    free_emxArray((emxArray__common*)&Acols);
    free_emxArray((emxArray__common*)&Avals);
    free_emxArray((emxArray__common*)&b);
    free_emxArray((emxArray__common*)&solver);
    free_emxArray((emxArray__common*)&x);
}
void mptSolveCRS_8args_api(const mxArray ** prhs, const mxArray **plhs) {

    emxArray_int32_T     Arows;
    emxArray_int32_T     Acols;
    emxArray_real_T      Avals;
    emxArray_real_T      b;
    emxArray_char_T      solver;
    emxArray_char_T      pctype;
    emxArray_real_T      x;

    real64_T             rtol;
    int32_T              maxiter;
    int32_T              *flag;
    real64_T             *relres;
    int32_T              *iter;

    /* Marshall in function inputs */
    if (mxGetNumberOfElements(prhs[0]) && mxGetClassID(prhs[0]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_8args:WrongInputType",
            "Input argument Arows has incorrect data type. int32 is expected.");
    alias_mxArray_to_emxArray(prhs[0], (emxArray__common *)&Arows, "Arows", 1);
    if (mxGetNumberOfElements(prhs[1]) && mxGetClassID(prhs[1]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_8args:WrongInputType",
            "Input argument Acols has incorrect data type. int32 is expected.");
    alias_mxArray_to_emxArray(prhs[1], (emxArray__common *)&Acols, "Acols", 1);
    if (mxGetNumberOfElements(prhs[2]) && mxGetClassID(prhs[2]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_8args:WrongInputType",
            "Input argument Avals has incorrect data type. double is expected.");
    alias_mxArray_to_emxArray(prhs[2], (emxArray__common *)&Avals, "Avals", 1);
    if (mxGetNumberOfElements(prhs[3]) && mxGetClassID(prhs[3]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_8args:WrongInputType",
            "Input argument b has incorrect data type. double is expected.");
    alias_mxArray_to_emxArray(prhs[3], (emxArray__common *)&b, "b", 1);
    if (mxGetNumberOfElements(prhs[4]) && mxGetClassID(prhs[4]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_8args:WrongInputType",
            "Input argument solver has incorrect data type. char is expected.");
    alias_mxArray_to_emxArray(prhs[4], (emxArray__common *)&solver, "solver", 2);
    if (mxGetNumberOfElements(prhs[5]) && mxGetClassID(prhs[5]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_8args:WrongInputType",
            "Input argument rtol has incorrect data type. double is expected.");
    if (mxGetNumberOfElements(prhs[5]) != 1)
        mexErrMsgIdAndTxt("mptSolveCRS_8args:WrongSizeOfInputArg",
            "Argument rtol should be a scalar.");
    rtol = *(real64_T*)mxGetData(prhs[5]);
    if (mxGetNumberOfElements(prhs[6]) && mxGetClassID(prhs[6]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_8args:WrongInputType",
            "Input argument maxiter has incorrect data type. int32 is expected.");
    if (mxGetNumberOfElements(prhs[6]) != 1)
        mexErrMsgIdAndTxt("mptSolveCRS_8args:WrongSizeOfInputArg",
            "Argument maxiter should be a scalar.");
    maxiter = *(int32_T*)mxGetData(prhs[6]);
    if (mxGetNumberOfElements(prhs[7]) && mxGetClassID(prhs[7]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_8args:WrongInputType",
            "Input argument pctype has incorrect data type. char is expected.");
    alias_mxArray_to_emxArray(prhs[7], (emxArray__common *)&pctype, "pctype", 2);

    /* Preallocate output variables */
    init_emxArray((emxArray__common*)&x, 1);
    {mwSize l_size[] = {1, 1};
    *(void **)&flag = prealloc_mxArray((mxArray**)&plhs[1], mxINT32_CLASS, 2, l_size); }
    {mwSize l_size[] = {1, 1};
    *(void **)&relres = prealloc_mxArray((mxArray**)&plhs[2], mxDOUBLE_CLASS, 2, l_size); }
    {mwSize l_size[] = {1, 1};
    *(void **)&iter = prealloc_mxArray((mxArray**)&plhs[3], mxINT32_CLASS, 2, l_size); }

    /* Invoke the target function */
    mptSolveCRS_initialize();

    mptSolveCRS_8args(&Arows, &Acols, &Avals, &b, &solver, rtol, maxiter, &pctype, &x, flag, relres, iter);

    mptSolveCRS_terminate();

    /* Marshall out function outputs */
    plhs[0] = move_emxArray_to_mxArray((emxArray__common*)&x, mxDOUBLE_CLASS);
    /* Nothing to do for plhs[1] */
    /* Nothing to do for plhs[2] */
    /* Nothing to do for plhs[3] */

    /* Free temporary variables */
    free_emxArray((emxArray__common*)&Arows);
    free_emxArray((emxArray__common*)&Acols);
    free_emxArray((emxArray__common*)&Avals);
    free_emxArray((emxArray__common*)&b);
    free_emxArray((emxArray__common*)&solver);
    free_emxArray((emxArray__common*)&pctype);
    free_emxArray((emxArray__common*)&x);
}
void mptSolveCRS_9args_api(const mxArray ** prhs, const mxArray **plhs) {

    emxArray_int32_T     Arows;
    emxArray_int32_T     Acols;
    emxArray_real_T      Avals;
    emxArray_real_T      b;
    emxArray_char_T      solver;
    emxArray_char_T      pctype;
    emxArray_char_T      solpack;
    emxArray_real_T      x;

    real64_T             rtol;
    int32_T              maxiter;
    int32_T              *flag;
    real64_T             *relres;
    int32_T              *iter;

    /* Marshall in function inputs */
    if (mxGetNumberOfElements(prhs[0]) && mxGetClassID(prhs[0]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_9args:WrongInputType",
            "Input argument Arows has incorrect data type. int32 is expected.");
    alias_mxArray_to_emxArray(prhs[0], (emxArray__common *)&Arows, "Arows", 1);
    if (mxGetNumberOfElements(prhs[1]) && mxGetClassID(prhs[1]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_9args:WrongInputType",
            "Input argument Acols has incorrect data type. int32 is expected.");
    alias_mxArray_to_emxArray(prhs[1], (emxArray__common *)&Acols, "Acols", 1);
    if (mxGetNumberOfElements(prhs[2]) && mxGetClassID(prhs[2]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_9args:WrongInputType",
            "Input argument Avals has incorrect data type. double is expected.");
    alias_mxArray_to_emxArray(prhs[2], (emxArray__common *)&Avals, "Avals", 1);
    if (mxGetNumberOfElements(prhs[3]) && mxGetClassID(prhs[3]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_9args:WrongInputType",
            "Input argument b has incorrect data type. double is expected.");
    alias_mxArray_to_emxArray(prhs[3], (emxArray__common *)&b, "b", 1);
    if (mxGetNumberOfElements(prhs[4]) && mxGetClassID(prhs[4]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_9args:WrongInputType",
            "Input argument solver has incorrect data type. char is expected.");
    alias_mxArray_to_emxArray(prhs[4], (emxArray__common *)&solver, "solver", 2);
    if (mxGetNumberOfElements(prhs[5]) && mxGetClassID(prhs[5]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_9args:WrongInputType",
            "Input argument rtol has incorrect data type. double is expected.");
    if (mxGetNumberOfElements(prhs[5]) != 1)
        mexErrMsgIdAndTxt("mptSolveCRS_9args:WrongSizeOfInputArg",
            "Argument rtol should be a scalar.");
    rtol = *(real64_T*)mxGetData(prhs[5]);
    if (mxGetNumberOfElements(prhs[6]) && mxGetClassID(prhs[6]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_9args:WrongInputType",
            "Input argument maxiter has incorrect data type. int32 is expected.");
    if (mxGetNumberOfElements(prhs[6]) != 1)
        mexErrMsgIdAndTxt("mptSolveCRS_9args:WrongSizeOfInputArg",
            "Argument maxiter should be a scalar.");
    maxiter = *(int32_T*)mxGetData(prhs[6]);
    if (mxGetNumberOfElements(prhs[7]) && mxGetClassID(prhs[7]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_9args:WrongInputType",
            "Input argument pctype has incorrect data type. char is expected.");
    alias_mxArray_to_emxArray(prhs[7], (emxArray__common *)&pctype, "pctype", 2);
    if (mxGetNumberOfElements(prhs[8]) && mxGetClassID(prhs[8]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_9args:WrongInputType",
            "Input argument solpack has incorrect data type. char is expected.");
    alias_mxArray_to_emxArray(prhs[8], (emxArray__common *)&solpack, "solpack", 2);

    /* Preallocate output variables */
    init_emxArray((emxArray__common*)&x, 1);
    {mwSize l_size[] = {1, 1};
    *(void **)&flag = prealloc_mxArray((mxArray**)&plhs[1], mxINT32_CLASS, 2, l_size); }
    {mwSize l_size[] = {1, 1};
    *(void **)&relres = prealloc_mxArray((mxArray**)&plhs[2], mxDOUBLE_CLASS, 2, l_size); }
    {mwSize l_size[] = {1, 1};
    *(void **)&iter = prealloc_mxArray((mxArray**)&plhs[3], mxINT32_CLASS, 2, l_size); }

    /* Invoke the target function */
    mptSolveCRS_initialize();

    mptSolveCRS_9args(&Arows, &Acols, &Avals, &b, &solver, rtol, maxiter, &pctype, &solpack, &x, flag, relres, iter);

    mptSolveCRS_terminate();

    /* Marshall out function outputs */
    plhs[0] = move_emxArray_to_mxArray((emxArray__common*)&x, mxDOUBLE_CLASS);
    /* Nothing to do for plhs[1] */
    /* Nothing to do for plhs[2] */
    /* Nothing to do for plhs[3] */

    /* Free temporary variables */
    free_emxArray((emxArray__common*)&Arows);
    free_emxArray((emxArray__common*)&Acols);
    free_emxArray((emxArray__common*)&Avals);
    free_emxArray((emxArray__common*)&b);
    free_emxArray((emxArray__common*)&solver);
    free_emxArray((emxArray__common*)&pctype);
    free_emxArray((emxArray__common*)&solpack);
    free_emxArray((emxArray__common*)&x);
}
void mptSolveCRS_10args_api(const mxArray ** prhs, const mxArray **plhs) {

    emxArray_int32_T     Arows;
    emxArray_int32_T     Acols;
    emxArray_real_T      Avals;
    emxArray_real_T      b;
    emxArray_char_T      solver;
    emxArray_char_T      pctype;
    emxArray_char_T      solpack;
    emxArray_real_T      x0;
    emxArray_real_T      x;

    real64_T             rtol;
    int32_T              maxiter;
    int32_T              *flag;
    real64_T             *relres;
    int32_T              *iter;

    /* Marshall in function inputs */
    if (mxGetNumberOfElements(prhs[0]) && mxGetClassID(prhs[0]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_10args:WrongInputType",
            "Input argument Arows has incorrect data type. int32 is expected.");
    alias_mxArray_to_emxArray(prhs[0], (emxArray__common *)&Arows, "Arows", 1);
    if (mxGetNumberOfElements(prhs[1]) && mxGetClassID(prhs[1]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_10args:WrongInputType",
            "Input argument Acols has incorrect data type. int32 is expected.");
    alias_mxArray_to_emxArray(prhs[1], (emxArray__common *)&Acols, "Acols", 1);
    if (mxGetNumberOfElements(prhs[2]) && mxGetClassID(prhs[2]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_10args:WrongInputType",
            "Input argument Avals has incorrect data type. double is expected.");
    alias_mxArray_to_emxArray(prhs[2], (emxArray__common *)&Avals, "Avals", 1);
    if (mxGetNumberOfElements(prhs[3]) && mxGetClassID(prhs[3]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_10args:WrongInputType",
            "Input argument b has incorrect data type. double is expected.");
    alias_mxArray_to_emxArray(prhs[3], (emxArray__common *)&b, "b", 1);
    if (mxGetNumberOfElements(prhs[4]) && mxGetClassID(prhs[4]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_10args:WrongInputType",
            "Input argument solver has incorrect data type. char is expected.");
    alias_mxArray_to_emxArray(prhs[4], (emxArray__common *)&solver, "solver", 2);
    if (mxGetNumberOfElements(prhs[5]) && mxGetClassID(prhs[5]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_10args:WrongInputType",
            "Input argument rtol has incorrect data type. double is expected.");
    if (mxGetNumberOfElements(prhs[5]) != 1)
        mexErrMsgIdAndTxt("mptSolveCRS_10args:WrongSizeOfInputArg",
            "Argument rtol should be a scalar.");
    rtol = *(real64_T*)mxGetData(prhs[5]);
    if (mxGetNumberOfElements(prhs[6]) && mxGetClassID(prhs[6]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_10args:WrongInputType",
            "Input argument maxiter has incorrect data type. int32 is expected.");
    if (mxGetNumberOfElements(prhs[6]) != 1)
        mexErrMsgIdAndTxt("mptSolveCRS_10args:WrongSizeOfInputArg",
            "Argument maxiter should be a scalar.");
    maxiter = *(int32_T*)mxGetData(prhs[6]);
    if (mxGetNumberOfElements(prhs[7]) && mxGetClassID(prhs[7]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_10args:WrongInputType",
            "Input argument pctype has incorrect data type. char is expected.");
    alias_mxArray_to_emxArray(prhs[7], (emxArray__common *)&pctype, "pctype", 2);
    if (mxGetNumberOfElements(prhs[8]) && mxGetClassID(prhs[8]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_10args:WrongInputType",
            "Input argument solpack has incorrect data type. char is expected.");
    alias_mxArray_to_emxArray(prhs[8], (emxArray__common *)&solpack, "solpack", 2);
    if (mxGetNumberOfElements(prhs[9]) && mxGetClassID(prhs[9]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_10args:WrongInputType",
            "Input argument x0 has incorrect data type. double is expected.");
    alias_mxArray_to_emxArray(prhs[9], (emxArray__common *)&x0, "x0", 1);

    /* Preallocate output variables */
    init_emxArray((emxArray__common*)&x, 1);
    {mwSize l_size[] = {1, 1};
    *(void **)&flag = prealloc_mxArray((mxArray**)&plhs[1], mxINT32_CLASS, 2, l_size); }
    {mwSize l_size[] = {1, 1};
    *(void **)&relres = prealloc_mxArray((mxArray**)&plhs[2], mxDOUBLE_CLASS, 2, l_size); }
    {mwSize l_size[] = {1, 1};
    *(void **)&iter = prealloc_mxArray((mxArray**)&plhs[3], mxINT32_CLASS, 2, l_size); }

    /* Invoke the target function */
    mptSolveCRS_initialize();

    mptSolveCRS_10args(&Arows, &Acols, &Avals, &b, &solver, rtol, maxiter, &pctype, &solpack, &x0, &x, flag, relres, iter);

    mptSolveCRS_terminate();

    /* Marshall out function outputs */
    plhs[0] = move_emxArray_to_mxArray((emxArray__common*)&x, mxDOUBLE_CLASS);
    /* Nothing to do for plhs[1] */
    /* Nothing to do for plhs[2] */
    /* Nothing to do for plhs[3] */

    /* Free temporary variables */
    free_emxArray((emxArray__common*)&Arows);
    free_emxArray((emxArray__common*)&Acols);
    free_emxArray((emxArray__common*)&Avals);
    free_emxArray((emxArray__common*)&b);
    free_emxArray((emxArray__common*)&solver);
    free_emxArray((emxArray__common*)&pctype);
    free_emxArray((emxArray__common*)&solpack);
    free_emxArray((emxArray__common*)&x0);
    free_emxArray((emxArray__common*)&x);
}
void mptSolveCRS_11args_api(const mxArray ** prhs, const mxArray **plhs) {

    emxArray_int32_T     Arows;
    emxArray_int32_T     Acols;
    emxArray_real_T      Avals;
    emxArray_real_T      b;
    emxArray_char_T      solver;
    emxArray_char_T      pctype;
    emxArray_char_T      solpack;
    emxArray_real_T      x0;
    emxArray_char_T      opts;
    emxArray_real_T      x;

    real64_T             rtol;
    int32_T              maxiter;
    int32_T              *flag;
    real64_T             *relres;
    int32_T              *iter;

    /* Marshall in function inputs */
    if (mxGetNumberOfElements(prhs[0]) && mxGetClassID(prhs[0]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_11args:WrongInputType",
            "Input argument Arows has incorrect data type. int32 is expected.");
    alias_mxArray_to_emxArray(prhs[0], (emxArray__common *)&Arows, "Arows", 1);
    if (mxGetNumberOfElements(prhs[1]) && mxGetClassID(prhs[1]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_11args:WrongInputType",
            "Input argument Acols has incorrect data type. int32 is expected.");
    alias_mxArray_to_emxArray(prhs[1], (emxArray__common *)&Acols, "Acols", 1);
    if (mxGetNumberOfElements(prhs[2]) && mxGetClassID(prhs[2]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_11args:WrongInputType",
            "Input argument Avals has incorrect data type. double is expected.");
    alias_mxArray_to_emxArray(prhs[2], (emxArray__common *)&Avals, "Avals", 1);
    if (mxGetNumberOfElements(prhs[3]) && mxGetClassID(prhs[3]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_11args:WrongInputType",
            "Input argument b has incorrect data type. double is expected.");
    alias_mxArray_to_emxArray(prhs[3], (emxArray__common *)&b, "b", 1);
    if (mxGetNumberOfElements(prhs[4]) && mxGetClassID(prhs[4]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_11args:WrongInputType",
            "Input argument solver has incorrect data type. char is expected.");
    alias_mxArray_to_emxArray(prhs[4], (emxArray__common *)&solver, "solver", 2);
    if (mxGetNumberOfElements(prhs[5]) && mxGetClassID(prhs[5]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_11args:WrongInputType",
            "Input argument rtol has incorrect data type. double is expected.");
    if (mxGetNumberOfElements(prhs[5]) != 1)
        mexErrMsgIdAndTxt("mptSolveCRS_11args:WrongSizeOfInputArg",
            "Argument rtol should be a scalar.");
    rtol = *(real64_T*)mxGetData(prhs[5]);
    if (mxGetNumberOfElements(prhs[6]) && mxGetClassID(prhs[6]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_11args:WrongInputType",
            "Input argument maxiter has incorrect data type. int32 is expected.");
    if (mxGetNumberOfElements(prhs[6]) != 1)
        mexErrMsgIdAndTxt("mptSolveCRS_11args:WrongSizeOfInputArg",
            "Argument maxiter should be a scalar.");
    maxiter = *(int32_T*)mxGetData(prhs[6]);
    if (mxGetNumberOfElements(prhs[7]) && mxGetClassID(prhs[7]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_11args:WrongInputType",
            "Input argument pctype has incorrect data type. char is expected.");
    alias_mxArray_to_emxArray(prhs[7], (emxArray__common *)&pctype, "pctype", 2);
    if (mxGetNumberOfElements(prhs[8]) && mxGetClassID(prhs[8]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_11args:WrongInputType",
            "Input argument solpack has incorrect data type. char is expected.");
    alias_mxArray_to_emxArray(prhs[8], (emxArray__common *)&solpack, "solpack", 2);
    if (mxGetNumberOfElements(prhs[9]) && mxGetClassID(prhs[9]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_11args:WrongInputType",
            "Input argument x0 has incorrect data type. double is expected.");
    alias_mxArray_to_emxArray(prhs[9], (emxArray__common *)&x0, "x0", 1);
    if (mxGetNumberOfElements(prhs[10]) && mxGetClassID(prhs[10]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("mptSolveCRS_11args:WrongInputType",
            "Input argument opts has incorrect data type. char is expected.");
    alias_mxArray_to_emxArray(prhs[10], (emxArray__common *)&opts, "opts", 2);

    /* Preallocate output variables */
    init_emxArray((emxArray__common*)&x, 1);
    {mwSize l_size[] = {1, 1};
    *(void **)&flag = prealloc_mxArray((mxArray**)&plhs[1], mxINT32_CLASS, 2, l_size); }
    {mwSize l_size[] = {1, 1};
    *(void **)&relres = prealloc_mxArray((mxArray**)&plhs[2], mxDOUBLE_CLASS, 2, l_size); }
    {mwSize l_size[] = {1, 1};
    *(void **)&iter = prealloc_mxArray((mxArray**)&plhs[3], mxINT32_CLASS, 2, l_size); }

    /* Invoke the target function */
    mptSolveCRS_initialize();

    mptSolveCRS_11args(&Arows, &Acols, &Avals, &b, &solver, rtol, maxiter, &pctype, &solpack, &x0, &opts, &x, flag, relres, iter);

    mptSolveCRS_terminate();

    /* Marshall out function outputs */
    plhs[0] = move_emxArray_to_mxArray((emxArray__common*)&x, mxDOUBLE_CLASS);
    /* Nothing to do for plhs[1] */
    /* Nothing to do for plhs[2] */
    /* Nothing to do for plhs[3] */

    /* Free temporary variables */
    free_emxArray((emxArray__common*)&Arows);
    free_emxArray((emxArray__common*)&Acols);
    free_emxArray((emxArray__common*)&Avals);
    free_emxArray((emxArray__common*)&b);
    free_emxArray((emxArray__common*)&solver);
    free_emxArray((emxArray__common*)&pctype);
    free_emxArray((emxArray__common*)&solpack);
    free_emxArray((emxArray__common*)&x0);
    free_emxArray((emxArray__common*)&opts);
    free_emxArray((emxArray__common*)&x);
}

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]) {
    /* Temporary copy for mex outputs. */
    mxArray *outputs[4];
    int i;
    int nOutputs = (nlhs < 1 ? 1 : nlhs);

    if (nrhs == 0) {
        if (nlhs > 4)
            mexErrMsgIdAndTxt("mptSolveCRS:TooManyOutputArguments","Too many output arguments for entry-point mptSolveCRS.");
        /* Call the API function. */
        mptSolveCRS_api(prhs, (const mxArray**)outputs);
    }
    else if (nrhs == 4) {
        if (nlhs > 4)
            mexErrMsgIdAndTxt("mptSolveCRS_4args:TooManyOutputArguments","Too many output arguments for entry-point mptSolveCRS_4args.");
        /* Call the API function. */
        mptSolveCRS_4args_api(prhs, (const mxArray**)outputs);
    }
    else if (nrhs == 5) {
        if (nlhs > 4)
            mexErrMsgIdAndTxt("mptSolveCRS_5args:TooManyOutputArguments","Too many output arguments for entry-point mptSolveCRS_5args.");
        /* Call the API function. */
        mptSolveCRS_5args_api(prhs, (const mxArray**)outputs);
    }
    else if (nrhs == 6) {
        if (nlhs > 4)
            mexErrMsgIdAndTxt("mptSolveCRS_6args:TooManyOutputArguments","Too many output arguments for entry-point mptSolveCRS_6args.");
        /* Call the API function. */
        mptSolveCRS_6args_api(prhs, (const mxArray**)outputs);
    }
    else if (nrhs == 7) {
        if (nlhs > 4)
            mexErrMsgIdAndTxt("mptSolveCRS_7args:TooManyOutputArguments","Too many output arguments for entry-point mptSolveCRS_7args.");
        /* Call the API function. */
        mptSolveCRS_7args_api(prhs, (const mxArray**)outputs);
    }
    else if (nrhs == 8) {
        if (nlhs > 4)
            mexErrMsgIdAndTxt("mptSolveCRS_8args:TooManyOutputArguments","Too many output arguments for entry-point mptSolveCRS_8args.");
        /* Call the API function. */
        mptSolveCRS_8args_api(prhs, (const mxArray**)outputs);
    }
    else if (nrhs == 9) {
        if (nlhs > 4)
            mexErrMsgIdAndTxt("mptSolveCRS_9args:TooManyOutputArguments","Too many output arguments for entry-point mptSolveCRS_9args.");
        /* Call the API function. */
        mptSolveCRS_9args_api(prhs, (const mxArray**)outputs);
    }
    else if (nrhs == 10) {
        if (nlhs > 4)
            mexErrMsgIdAndTxt("mptSolveCRS_10args:TooManyOutputArguments","Too many output arguments for entry-point mptSolveCRS_10args.");
        /* Call the API function. */
        mptSolveCRS_10args_api(prhs, (const mxArray**)outputs);
    }
    else if (nrhs == 11) {
        if (nlhs > 4)
            mexErrMsgIdAndTxt("mptSolveCRS_11args:TooManyOutputArguments","Too many output arguments for entry-point mptSolveCRS_11args.");
        /* Call the API function. */
        mptSolveCRS_11args_api(prhs, (const mxArray**)outputs);
    }
    else
        mexErrMsgIdAndTxt("mptSolveCRS:WrongNumberOfInputs","Incorrect number of input variables for entry-point mptSolveCRS.");

    /* Copy over outputs to the caller. */
    for (i = 0; i < nOutputs; ++i) {
        plhs[i] = outputs[i];
    }
}